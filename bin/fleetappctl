#!/bin/bash
#
# Usage:
#	deployit.sh [deploy|undeploy] -d deployment-descriptor  [-e environment-file] 
#
# Description
#	Deploys the fleet unit files described in the deployment descriptor. 
#	The unit files referenced in the deployment-descriptor may have placeholders for
#	environment specific variables. These are indicated refered to by curly brackets {{ }}
#	
DEPLOY_DIR=.deployment
ENVFILE=
DEPLOYMENT_DESCRIPTOR=


function parseCommandLine() {
        USAGE="Usage: $(basename $0) [-d deployment-descriptor] [-e environment-file]  (prepare | submit | load | start | stop | deploy | stop | undeploy)"

        while getopts "d:e:" OPT; do
                case $OPT in
                        e)
                                ENVFILE=$OPTARG
				if [ ! -f "$ENVFILE" ] ; then
					echo $USAGE >&2
					echo "	$ENVFILE is not a file." >&2
					exit 1
				fi
				shift 2;
                                ;;
                        d)
                                DESCRIPTOR=$OPTARG
				shift 2;
                                ;;
                        \*)
                                echo $USAGE >&2
                                exit 1
                                ;;
                esac
        done
	
	case $1 in 
		prepare|submit|load|start|stop|destroy)
			COMMAND=$1
			;;
		*)
			echo $USAGE >&2
			exit 1
			;;
	esac
	
	if [ -z "$DESCRIPTOR" ] ; then
		if [ -f deployit-manifest.xml ] ; then
			echo "INFO: using default deployment descriptor deployit-manifest.xml" >&2
			DESCRIPTOR=deployit-manifest.xml
		else
			echo $USAGE >&2
			echo "ERROR: deployment descriptor is missing" >&2
			exit 1
		fi
	fi

}

function descriptorToTable() {
	 xml sel -t -m //fleet.UnitConfigurationFile \
		-v 'concat(@name, "^", @file)' \
		-v 'concat("^", ./scanPlaceHolders)' \
		-v 'concat("^", ./startUnit)' \
		-v 'concat("^", ./numberOfInstances)' \
		-m . \
		-n \
		$1
}

function isTemplateFile() {
	local IS_TEMPLATE=$(echo $1 | egrep -e '@.(service|socket|device|mount|automount|swap|target|path|time|snapshot|slice|scope)')
	test -n "$IS_TEMPLATE"
}


function instanceName() {
	echo $1 | sed -e "s/@\(\.[^\.]*\)$/@$2\1/"
}

function forEachUnit() {
	local FILTER=cat
	if [ "$1" == "--reverse" ] ; then
		shift
		FILTER="sed -n '1!G;h;\$p'"
	fi

	descriptorToTable $DESCRIPTOR | eval $FILTER | while read LINE ; do
		NAME=$(echo $LINE | awk  -F^ '{print $1}')
		FILENAME=$(echo $LINE | awk  -F^ '{print $2}')
		SCAN_PLACE_HOLDERS=$(echo $LINE | awk  -F^ '{if ($3 != "false")  print "true"; else print $3}')
		START_UNIT=$(echo $LINE | awk  -F^ '{if ($4 == "") print "true"; else print $4}')
		NR_OF_INSTANCES=$(echo $LINE | awk  -F^ '{if ($5 == "") print "1"; else print $5}')
		eval "$@" "$NAME" "$FILENAME" "$SCAN_PLACE_HOLDERS" "$START_UNIT" "$NR_OF_INSTANCES"
	done
}

function forEachInstance() {
	local FILTER=cat
	local INCLUDE_TEMPLATE=false
	if [ "$1" == "--reverse" ] ; then
		shift
		FILTER="sed -n '1!G;h;\$p'"
	fi

	descriptorToTable $DESCRIPTOR | eval $FILTER | while read LINE ; do
		NAME=$(echo $LINE | awk  -F^ '{print $1}')
		FILENAME=$(echo $LINE | awk  -F^ '{print $2}')
		SCAN_PLACE_HOLDERS=$(echo $LINE | awk  -F^ '{if ($3 != "false") print "true"; else print $3}')
		START_UNIT=$(echo $LINE | awk  -F^ '{if ($4 == "") print "true"; else print $4}')
		NR_OF_INSTANCES=$(echo $LINE | awk  -F^ '{if ($5 == "") print "1"; else print $5}')
		eval "$@" "$FILENAME" "$FILENAME" "$FILENAME" "$SCAN_PLACE_HOLDERS" "$START_UNIT" 
		if  isTemplateFile $FILENAME ; then
			NR=1
			while [ $NR -le ${NR_OF_INSTANCES:-1} ] ; do
				INSTANCE=$(instanceName $FILENAME $NR)
				eval "$@" "$NAME" "$INSTANCE" "$FILENAME" "$SCAN_PLACE_HOLDERS" "$START_UNIT" 
				NR=$(($NR + 1))
			done
		fi
	done
}

function findPlaceHolders() {
	local FILENAME=$2
	sed -e 's/{{/#{{/g' -e 's/}}/}}#/g' $FILENAME | tr '#' '\n'  |  sed -n 's/{{\([^}]*\)}}/\1/p'
}


function generateSedPlaceHolders() {
	cat $ENVFILE | grep -v ^# | grep -v '^[ \t]*$' | while read LINE  ; do
		KEY=$(echo $LINE | sed -e 's/^\([^=]*\)=.*/\1/' | sed -e 's/\\/\\\\/g' -e 's/\//\\\//g')
		VALUE=$(echo $LINE | sed -e 's/^[^=]*=\(.*\)/\1/' | sed -e 's/\\/\\\\/g' -e 's/\//\\\//g')
		echo "s/{{$KEY}}/$VALUE/g" 
	done
}

function checkPreconditions() {
	if [ -z "$ENVFILE" ] ; then
		 UNIT_WITH_PLACEHOLDERS=$(descriptorToTable $DESCRIPTOR | awk -F^ '{ if($3 == "true") { printf("%s,", $2); }}' | sed -e 's/,$//')
		if [ -n "$UNIT_WITH_PLACEHOLDERS" ] ; then
			echo "WARN: No environment specified, but units with placeholders in deployment: $UNIT_WITH_PLACEHOLDERS" >&2
		fi
	fi
}

function removeLineContinuations() {
sed  -e '
: again
/\\$/ {
    N
    s/\\\n/ /
    t again
}'

}


function copyUnitFile() {
	local FILENAME=$2
	local SCAN_PLACE_HOLDERS=$3
	local TARGET_PATH=$DEPLOY_DIR/$(basename $FILENAME)

	if [ $SCAN_PLACE_HOLDERS == "true" ] ; then
		[ -z "$ENVFILE" ] || generateSedPlaceHolders  > $DEPLOY_DIR/sedscript
		sed -f $DEPLOY_DIR/sedscript $FILENAME | removeLineContinuations > $TARGET_PATH
	else
		cat $FILENAME | removeLineContinuations > $TARGET_PATH
	fi
}

function copyUnitFiles() {
	mkdir -p $DEPLOY_DIR

	forEachUnit copyUnitFile
}

function loadUnitFile() {
	local INSTANCE=$2
	
	if ! isTemplateFile $INSTANCE ; then
		local DSTATE=$(fleetctl list-unit-files -fields=unit,dstate -no-legend | awk "/^$INSTANCE/{ print \$2;}")
		if [  "$DSTATE" == "inactive"  -o -z "$DSTATE" ] ; then
			echo "INFO: loading $INSTANCE." >&2
			(cd $DEPLOY_DIR ; fleetctl load $INSTANCE)
		else
			echo "INFO: $INSTANCE already loaded." >&2
		fi
	fi
}

function getUnitState() {
        fleetctl list-units -fields=unit,sub -no-legend | grep "^$1" | cut -f2
}

function waitUntilUnitIsGone() {
        waitUntilUnitState $1 '^$'
}

function waitUntilUnitState() {
	local OLDSTATE=""
        local STATE=$(getUnitState $1)
        while ! (echo $STATE | egrep -q "$2"); do
		if [ "$STATE" != "$OLDSTATE" ] ; then
			test -n "$OLDSTATE" && echo
			echo  -n "INFO: $1 in state ${STATE}";
		else
			echo -n .
		fi
                sleep 1;
		OLDSTATE=$STATE
                STATE=$(getUnitState $1)
        done
	test -n "$OLDSTATE" && echo
	echo  "INFO: $1 in state ${STATE}.";
}

function startUnitFile() {
	INSTANCE=$2
	FILENAME=$3
	START=$5
	if ! isTemplateFile $INSTANCE ; then
		submitUnitFile "$@"
		loadUnitFile "$@"
		if  [ "$START" != "false" ] ; then
			echo "INFO: starting $INSTANCE." >&2
			(cd $DEPLOY_DIR ; fleetctl start $INSTANCE; waitUntilUnitState $INSTANCE running)
		fi
	else
		submitUnitFile "$@"
	fi
}

function stopUnitFile() {
	INSTANCE=$2
	FILENAME=$3
	START=$5
	if ! isTemplateFile $INSTANCE ; then
		if  [ "$START" != "false" ] ; then
			echo "INFO: stopping $INSTANCE." >&2
			(cd $DEPLOY_DIR ; fleetctl stop $INSTANCE)
		fi
	fi
}

function destroyUnitFile() {
	local INSTANCE=$2
	local FILENAME=$3
	(cd $DEPLOY_DIR ; fleetctl destroy $INSTANCE)
}

function submitUnitFile() {
	local INSTANCE=$2
	local FILENAME=$3
	LOADED=$(fleetctl list-unit-files -no-legend -fields=unit | grep -e "^$FILENAME")
	if [ -n "$LOADED" ] ; then
		if fleetctl cat $INSTANCE | diff -B -w $DEPLOY_DIR/$FILENAME - >/dev/null ; then
			  echo "INFO: unit $INSTANCE unchanged."
		else
			echo "INFO: unit $INSTANCE differs, destroying old one"
			( cd $DEPLOY_DIR ; fleetctl destroy $INSTANCE
			  echo "INFO: submitting $INSTANCE.."
			  fleetctl submit $INSTANCE )
		fi
	else
		echo "INFO: submitting $1.."
		(cd $DEPLOY_DIR ; fleetctl submit $INSTANCE )
	fi
}


parseCommandLine "$@"
checkPreconditions

case $COMMAND in
	show-place-holders)
		forEachUnit findPlaceHolders | sort -u
		;;
	prepare)
		forEachUnit copyUnitFile
		;;
	submit)
		forEachUnit copyUnitFile
		forEachInstance submitUnitFile
		;;
	load)
		forEachUnit copyUnitFile
		forEachInstance submitUnitFile
		forEachInstance loadUnitFile
		;;
	start)
		forEachUnit copyUnitFile
		forEachInstance startUnitFile
		;;
	stop)
		forEachInstance --reverse stopUnitFile
		;;
	destroy)
		forEachInstance --reverse stopUnitFile
		forEachInstance --reverse --include-template destroyUnitFile
		;;
	*)
		echo ERROR: $COMMAND not yet implemented... >&2
		exit 1
		;;
esac
