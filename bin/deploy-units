#!/bin/bash
#
# Usage:
#	deployit.sh [deploy|undeploy] -d deployment-descriptor  [-e environment-file] 
#
# Description
#	Deploys the fleet unit files described in the deployment descriptor. 
#	The unit files referenced in the deployment-descriptor may have placeholders for
#	environment specific variables. These are indicated refered to by curly brackets {{ }}
#	
DEPLOY_DIR=.deployment
ENVFILE=
DEPLOYMENT_DESCRIPTOR=


function parseCommandLine() {
        USAGE="Usage: $(basename $0) [-d deployment-descriptor] [-e environment-file]  (prepare | submit | start | stop | deploy | stop | undeploy)"

        while getopts "d:e:" OPT; do
                case $OPT in
                        e)
                                ENVFILE=$OPTARG
				if [ ! -f "$ENVFILE" ] ; then
					echo $USAGE >&2
					echo "	$ENVFILE is not a file." >&2
					exit 1
				fi
				shift 2;
                                ;;
                        d)
                                DESCRIPTOR=$OPTARG
				shift 2;
                                ;;
                        \*)
                                echo $USAGE >&2
                                exit 1
                                ;;
                esac
        done
	
	echo $1

	case $1 in 
		prepare|submit|start|stop|deploy|undeploy)
			COMMAND=$1
			;;
		*)
			echo $USAGE >&2
			exit 1
			;;
	esac
	echo $OPTARG
	case $1 in 
		prepare|submit|start|stop|deploy|undeploy)
			COMMAND=$1
			;;
		*)
			echo $USAGE >&2
			exit 1
			;;
	esac
	
	if [ -z "$DESCRIPTOR" ] ; then
		if [ -f deployit-manifest.xml ] ; then
			echo "INFO: using default deployment descriptor deployit-manifest.xml" >&2
			DESCRIPTOR=deployit-manifest.xml
		else
			echo $USAGE >&2
			echo "ERROR: deployment descriptor is missing" >&2
			exit 1
		fi
	fi

}

function descriptorToTable() {
	 xml sel -t -m //fleet.UnitConfigurationFile \
		-v 'concat(@name, "^", @file)' \
		-v 'concat("^", ./scanPlaceholders)' \
		-v 'concat("^", ./startUnit)' \
		-v 'concat("^", ./numberOfInstances)' \
		-m . \
		-n \
		$1
}

function findAllPlaceholders() {
	descriptorToTable $DESCRIPTOR | while read LINE ; do
		FILENAME=$(echo $LINE | awk  'BEGIN {FS="^"}{print $2}')
		PLACEHOLDERS=$(sed -e 's/{{/#{{/g' -e 's/}}/}}#/g' $FILENAME | tr '#' '\n'  |  sed -n 's/{{\([^}]*\)}}/\1/p')
	done
}

function generateSedPlaceholders() {
	cat $ENVFILE | grep -v ^# | grep -v '^[ \t]*$' | while read LINE  ; do
		KEY=$(echo $LINE | sed -e 's/^\([^=]*\)=.*/\1/' | sed -e 's/\\/\\\\/g' -e 's/\//\\\//g')
		VALUE=$(echo $LINE | sed -e 's/^[^=]*=\(.*\)/\1/' | sed -e 's/\\/\\\\/g' -e 's/\//\\\//g')
		echo "s/{{$KEY}}/$VALUE/g" 
	done
}

function checkPreconditions() {
	if [ -z "$ENVFILE" ] ; then
		 UNIT_WITH_PLACEHOLDERS=$(descriptorToTable $DESCRIPTOR | awk -F^ '{ if($3 == "true") { printf("%s,", $2); }}' | sed -e 's/,$//')
		if [ -n "$UNIT_WITH_PLACEHOLDERS" ] ; then
			echo "ERROR: No environment specified, but units with placeholders in deployment: $UNIT_WITH_PLACEHOLDERS" >&2
			exit 1
		fi
	fi
}

function removeLineContinuations() {
sed  -e '
: again
/\\$/ {
    N
    s/\\\n/ /
    t again
}' -e '/^[ \t]*$/d'

}

function copyUnitFiles() {
	mkdir -p $DEPLOY_DIR

	if [ -n "$ENVFILE" ] ; then
		generateSedPlaceholders  > $DEPLOY_DIR/sedscript
	fi
	descriptorToTable $DESCRIPTOR | while read LINE ; do
		FILENAME=$(echo $LINE | awk  -F^ '{print $2}')
		SCAN=$(echo $LINE | awk  -F^ '{print $3}')
		TARGET_PATH=$DEPLOY_DIR/$(basename $FILENAME)
		if [ $SCAN == "true" ] ; then
			sed -f $DEPLOY_DIR/sedscript $FILENAME | removeLineContinuations > $TARGET_PATH
		else
			cat $FILENAME | removeLineContinuations > $TARGET_PATH
		fi
	done
}

function isTemplateFile() {
	local IS_TEMPLATE=$(echo $1 | egrep -e '@.(service|socket|device|mount|automount|swap|target|path|time|snapshot|slice|scope)')
	test -n "$IS_TEMPLATE"
}

function instanceName() {
	echo $1 | sed -e "s/@\(\.[^\.]*\)$/@$2\1/"
}

function startUnitInstance() {
	FILENAME=$1
	(cd $DEPLOY_DIR ; fleetctl start $FILENAME)
}

function startUnitFiles() {
	descriptorToTable $DESCRIPTOR | awk -F^ '{if ($4 != "false") { print $0;}}' | while read LINE ; do
		NAME=$(echo $LINE | awk  -F^ '{print $1}')
		FILENAME=$(echo $LINE | awk  -F^ '{print $2}')
		NR_OF_INSTANCES=$(echo $LINE | awk  -F^ '{print $5}')
		if  isTemplateFile $FILENAME ; then
			NR=1
			while [ $NR -le ${NR_OF_INSTANCES:-1} ] ; do
				INSTANCE=$(instanceName $FILENAME $NR)
				echo "INFO: starting $INSTANCE." >&2
				(cd $DEPLOY_DIR ; fleetctl start $INSTANCE)
				NR=$(($NR + 1))
			done
		else
			echo "INFO: starting $NAME." >&2
			(cd $DEPLOY_DIR ; fleetctl start $FILENAME)
		fi
	done
}

function submitUnitFiles() {
	descriptorToTable $DESCRIPTOR | while read LINE ; do
		NAME=$(echo $LINE | awk  -F^ '{print $1}')
		FILENAME=$(echo $LINE | awk  -F^ '{print $2}')
		echo "INFO: submitting $FILENAME." >&2
		(cd $DEPLOY_DIR ; fleetctl submit $FILENAME)
	done
}

parseCommandLine "$@"
checkPreconditions

case $COMMAND in
	prepare)
		copyUnitFiles
		;;
	submit)
		copyUnitFiles
		submitUnitFiles
		;;
	start)
		copyUnitFiles
		submitUnitFiles
		startUnitFiles
		;;
	*)
		echo ERROR: $COMMAND not yet implemented... >&2
		exit 1
		;;
esac
